\subsubsection{Многопоточное программирование}
Допустим, мы хотим перемножить матрицы. Ясно, что левую часть полученной матрицы можно считать независимо от правой. Можно использовать стандартный подход ``разделяй и властвуй''.

Но если у нас есть один процессор, то мы не получим выигрыша, а только проигрыш на рекурсию и переключение между процессами.

Как происходит перевключение? В операционной системе есть так называемый scheduler, который следит за всем этим. У каждого процесса контекст, то есть всякие указатели на исполняемый в данный момент участок кода и так далее. При переключении процесса нужно записать контекст в память/регистры, поэтому это требует времени.
Такая многозадачность (со скедулером) называется вытесняемой.

Есть другие виды многозадачности, например такой:
В сами потоки записаны команды на передачу управления. Плюс в том, что меньше накладных расходов, а минус в том, что если в программе баг, то может повиснуть вся система.

Многопоточность не всегда возможна в рамках одной программы, потому что некоторые алгоритмы требуют последовательное выполнение.
Но при этом она необходима на уровне операционной системы для поддержки многозадачности.

Обычно кроме потоков, которые что-то считают есть еще и управляемый поток, который делает join, то есть ждет, пока доработают все потоки и тогда уже выводит результат.

\paragraph{Атомарность}

Запустим каждую функцию в своем потоке.
\begin{minted}{c++}
SomeClass n = 0;
void f1() { // Поток t1
  while(true)
    n.change();
}
void f2() { // Поток t2
  while(true)
    cout << n;
}
\end{minted}
Какая здесь могут быть проблемы?
\begin{enumerate}
  \item[Неатомарность операции t1] Поток t2 может попробовать вывести n в то время как над ним выполняется операция \cc{increment}. Таким образом, может произойти попытка вывода объекта \cc{n} в неконсистемнтном состоянии.
  \item[Кэширование] Разберем в следующий раз.
\end{enumerate}

